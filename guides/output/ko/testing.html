<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>레일스 어플리케이션 테스트 가이드(A Guide to Testing Rails Applications) {원문·전체} — Ruby on Rails Guides</title>
<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />

<link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" />

<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
</head>
<body class="guide">
  <div>
    <img src="images/edge_badge.png" alt="edge-badge" id="edge-badge" />
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        More Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="http://rubyonrails.org/">개요</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/download">다운로드</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/deploy">배포</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">코드</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/screencasts">스크린캐스트</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/documentation">도큐먼트</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/ecosystem">생태계</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/community">커뮤니티</a></li>
        <li class="more-info"><a href="http://weblog.rubyonrails.org/">블로그</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">홈</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu" class="guides-index-item nav-item">가이드 인덱스</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
              <dl class="L">
                <dt>Start Here</dt>
                <dd><a href="getting_started.html">Getting Started with Rails</a></dd>
                <dt>Models</dt>
                <dd><a href="active_record_basics.html">Active Record Basics</a></dd>
                <dd><a href="active_record_migrations.html">Active Record Migrations</a></dd>
                <dd><a href="active_record_validations.html">Active Record Validations</a></dd>
                <dd><a href="active_record_callbacks.html">Active Record Callbacks</a></dd>
                <dd><a href="association_basics.html">Active Record Associations</a></dd>
                <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
                <dt>Views</dt>
                <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
                <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
                <dt>Controllers</dt>
                <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
                <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
              </dl>
              <dl class="R">
                <dt>Digging Deeper</dt>
                <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
                <dd><a href="i18n.html">Rails Internationalization API</a></dd>
                <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
                <dd><a href="active_job_basics.html">Active Job Basics</a></dd>
                <dd><a href="security.html">Securing Rails Applications</a></dd>
                <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
                <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
                <dd><a href="command_line.html">Rails Command Line Tools and Rake Tasks</a></dd>
                <dd><a href="asset_pipeline.html">Asset Pipeline</a></dd>
                <dd><a href="working_with_javascript_in_rails.html">Working with JavaScript in Rails</a></dd>
                <dd><a href="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants</a></dd>
                <dt>Extending Rails</dt>
                <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                <dd><a href="generators.html">Creating and Customizing Rails Generators</a></dd>
                <dt>Contributing to Ruby on Rails</dt>
                <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
                <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
                <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>
                <dt>Maintenance Policy</dt>
                <dd><a href="maintenance_policy.html">Maintenance Policy</a></dd>
                <dt>Release Notes</dt>
                <dd><a href="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</a></dd>
                <dd><a href="4_2_release_notes.html">Ruby on Rails 4.2 Release Notes</a></dd>
                <dd><a href="4_1_release_notes.html">Ruby on Rails 4.1 Release Notes</a></dd>
                <dd><a href="4_0_release_notes.html">Ruby on Rails 4.0 Release Notes</a></dd>
                <dd><a href="3_2_release_notes.html">Ruby on Rails 3.2 Release Notes</a></dd>
                <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes</a></dd>
                <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</a></dd>
                <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</a></dd>
                <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</a></dd>
              </dl>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">기여하기</a></li>
        <li><a class="nav-item" href="credits.html">크레딧</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">가이드 인덱스</option>
              <optgroup label="Start Here">
                  <option value="getting_started.html">Getting Started with Rails</option>
              </optgroup>
              <optgroup label="Models">
                  <option value="active_record_basics.html">Active Record Basics</option>
                  <option value="active_record_migrations.html">Active Record Migrations</option>
                  <option value="active_record_validations.html">Active Record Validations</option>
                  <option value="active_record_callbacks.html">Active Record Callbacks</option>
                  <option value="association_basics.html">Active Record Associations</option>
                  <option value="active_record_querying.html">Active Record Query Interface</option>
              </optgroup>
              <optgroup label="Views">
                  <option value="layouts_and_rendering.html">Layouts and Rendering in Rails</option>
                  <option value="form_helpers.html">Action View Form Helpers</option>
              </optgroup>
              <optgroup label="Controllers">
                  <option value="action_controller_overview.html">Action Controller Overview</option>
                  <option value="routing.html">Rails Routing from the Outside In</option>
              </optgroup>
              <optgroup label="Digging Deeper">
                  <option value="active_support_core_extensions.html">Active Support Core Extensions</option>
                  <option value="i18n.html">Rails Internationalization API</option>
                  <option value="action_mailer_basics.html">Action Mailer Basics</option>
                  <option value="active_job_basics.html">Active Job Basics</option>
                  <option value="security.html">Securing Rails Applications</option>
                  <option value="debugging_rails_applications.html">Debugging Rails Applications</option>
                  <option value="configuring.html">Configuring Rails Applications</option>
                  <option value="command_line.html">Rails Command Line Tools and Rake Tasks</option>
                  <option value="asset_pipeline.html">Asset Pipeline</option>
                  <option value="working_with_javascript_in_rails.html">Working with JavaScript in Rails</option>
                  <option value="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants</option>
              </optgroup>
              <optgroup label="Extending Rails">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators</option>
              </optgroup>
              <optgroup label="Contributing to Ruby on Rails">
                  <option value="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</option>
                  <option value="api_documentation_guidelines.html">API Documentation Guidelines</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</option>
              </optgroup>
              <optgroup label="Maintenance Policy">
                  <option value="maintenance_policy.html">Maintenance Policy</option>
              </optgroup>
              <optgroup label="Release Notes">
                  <option value="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</option>
                  <option value="4_2_release_notes.html">Ruby on Rails 4.2 Release Notes</option>
                  <option value="4_1_release_notes.html">Ruby on Rails 4.1 Release Notes</option>
                  <option value="4_0_release_notes.html">Ruby on Rails 4.0 Release Notes</option>
                  <option value="3_2_release_notes.html">Ruby on Rails 3.2 Release Notes</option>
                  <option value="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes</option>
                  <option value="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</option>
                  <option value="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</option>
                  <option value="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</option>
              </optgroup>
          </select>
        </li>
      </ul>
      </div>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>레일스 어플리케이션 테스트 가이드<span class="original-text-h">(A Guide to Testing Rails Applications)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href='#' class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup></h2><p>본 가이드는 어플리케이션을 테스트하기 위한 레일스의 내장 메카니즘에 대해서 다룹니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href='#' class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">This guide covers built-in mechanisms in Rails for testing your application.</p><p>본 가이드를 읽은 후에 아래의 내용을 알게 될 것입니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href='#' class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">After reading this guide, you will know:</p>
<ul>
<li><p>레일스 테스트 용어 <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href='#' class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Rails testing terminology.</p></li>
<li><p>어플리케이션에 대한 유닛, 기능, 통합 테스트를 작성하는 방법 <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href='#' class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">How to write unit, functional, and integration tests for your application.</p></li>
<li><p>기타 인기있는 테스트 방법과 플러그인 <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href='#' class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Other popular testing approaches and plugins.</p></li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li><a href="#%EB%A0%88%EC%9D%BC%EC%8A%A4-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%97%90-%EB%8C%80%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%99%9C-%EC%9E%91%EC%84%B1%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80-questionmark-why-write-tests-for-your-rails-applications-questionmark-%EC%9B%90%EB%AC%B8%C2%B7%EC%A0%84%EC%B2%B4">레일스 어플리케이션에 대한 테스트를 왜 작성해야 하는가?<span class="original-text-h">(Why Write Tests for your Rails Applications?)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup></a></li>
<li>
<a href="#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%9C-%EC%86%8C%EA%B0%9C-introduction-to-testing-%EC%9B%90%EB%AC%B8%C2%B7%EC%A0%84%EC%B2%B4">테스트에 대한 소개<span class="original-text-h">(Introduction to Testing)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup></a>

<ul>
<li><a href="#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD-the-test-environment-%EC%9B%90%EB%AC%B8%C2%B7%EC%A0%84%EC%B2%B4">테스트 환경<span class="original-text-h">(The Test Environment)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup></a></li>
<li><a href="#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A0%88%EC%9D%BC%EC%8A%A4-%EC%A4%80%EB%B9%84-%EC%9E%91%EC%97%85-rails-sets-up-for-testing-from-the-word-go-%EC%9B%90%EB%AC%B8%C2%B7%EC%A0%84%EC%B2%B4">테스트를 위한 레일스 준비 작업<span class="original-text-h">(Rails Sets up for Testing from the Word Go)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup></a></li>
<li><a href="#fixture%EC%97%90-%EB%8C%80%ED%95%9C-%EC%88%A8%EC%9D%80-%EC%9D%B4%EC%95%BC%EA%B8%B0-the-low-down-on-fixtures-%EC%9B%90%EB%AC%B8%C2%B7%EC%A0%84%EC%B2%B4">Fixture에 대한 숨은 이야기<span class="original-text-h">(The Low-Down on Fixtures)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup></a></li>
</ul>
</li>
<li>
<a href="#%EB%AA%A8%EB%8D%B8%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9C%A0%EB%8B%9B-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0-unit-testing-your-models-%EC%9B%90%EB%AC%B8%C2%B7%EC%A0%84%EC%B2%B4">모델에 대한 유닛 테스트하기<span class="original-text-h">(Unit Testing your Models)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup></a>

<ul>
<li><a href="#preparing-your-application-for-testing">Preparing your Application for Testing</a></li>
<li><a href="#running-tests">Running Tests</a></li>
<li><a href="#what-to-include-in-your-unit-tests">What to Include in Your Unit Tests</a></li>
<li><a href="#available-assertions">Available Assertions</a></li>
<li><a href="#rails-specific-assertions">Rails Specific Assertions</a></li>
</ul>
</li>
<li>
<a href="#functional-tests-for-your-controllers">Functional Tests for Your Controllers</a>

<ul>
<li><a href="#what-to-include-in-your-functional-tests">What to Include in your Functional Tests</a></li>
<li><a href="#available-request-types-for-functional-tests">Available Request Types for Functional Tests</a></li>
<li><a href="#the-four-hashes-of-the-apocalypse">The Four Hashes of the Apocalypse</a></li>
<li><a href="#instance-variables-available">Instance Variables Available</a></li>
<li><a href="#setting-headers-and-cgi-variables">Setting Headers and CGI variables</a></li>
<li><a href="#testing-templates-and-layouts">Testing Templates and Layouts</a></li>
<li><a href="#a-fuller-functional-test-example">A Fuller Functional Test Example</a></li>
<li><a href="#testing-views">Testing Views</a></li>
</ul>
</li>
<li>
<a href="#integration-testing">Integration Testing</a>

<ul>
<li><a href="#helpers-available-for-integration-tests">Helpers Available for Integration Tests</a></li>
<li><a href="#integration-testing-examples">Integration Testing Examples</a></li>
</ul>
</li>
<li><a href="#rake-tasks-for-running-your-tests">Rake Tasks for Running your Tests</a></li>
<li><a href="#brief-note-about-minitest">Brief Note About <code>MiniTest</code></a></li>
<li><a href="#setup-and-teardown">Setup and Teardown</a></li>
<li><a href="#testing-routes">Testing Routes</a></li>
<li>
<a href="#testing-your-mailers">Testing Your Mailers</a>

<ul>
<li><a href="#keeping-the-postman-in-check">Keeping the Postman in Check</a></li>
<li><a href="#unit-testing">Unit Testing</a></li>
<li><a href="#functional-testing">Functional Testing</a></li>
</ul>
</li>
<li><a href="#other-testing-approaches">Other Testing Approaches</a></li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="레일스-어플리케이션에-대한-테스트를-왜-작성해야-하는가-questionmark-why-write-tests-for-your-rails-applications-questionmark-원문·전체">1 레일스 어플리케이션에 대한 테스트를 왜 작성해야 하는가?<span class="original-text-h">(Why Write Tests for your Rails Applications?)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h3><p>레일스는 테스트를 매우 쉽게 작성할 수 있게 해 줍니다. 모델과 컨트롤러를 생성할 때 테스트 코드의 기본 골격을 만들어 주어 테스트를 쉽게 시작할 수 있도록 해 줍니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Rails makes it super easy to write your tests. It starts by producing skeleton test code while you are creating your models and controllers.</p><p>단순히 레일스 테스트를 실행만 하면, 주요 코드를 리팩토링한 후에도 원래의 기능이 제대로 유지되는 지를 확인할 수 있습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">By simply running your Rails tests you can ensure your code adheres to the desired functionality even after some major code refactoring.</p><p>또한 레일스 테스트는 브라우저 요청을 시뮬레이션할 수 있어서 브라우저에서 직접 테스트해 보지 않고도 어플리케이션의 반응을 테스트해 볼 수 있습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Rails tests can also simulate browser requests and thus you can test your application's response without having to test it through your browser.</p><h3 id="테스트에-대한-소개-introduction-to-testing-원문·전체">2 테스트에 대한 소개<span class="original-text-h">(Introduction to Testing)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h3><p>테스트에 대한 지원은 처음부터 레일스에 잘 짜여져 있었습니다. 따라서 "오~, 테스트하는 것이 새로운 것이고 멋진 것이니까 테스트에 대한 지원을 추가하자"와 같이 갑작스러운 것은 아니었습니다. 모든 레일스 어플리케이션이 데이터베이스와 잘 연동되기 때문에 결과적으로 테스트 작성시에도 데이터베이스가 필요하게 됩니다. 효과적인 테스트를 작성하기 위해서는 이와 같은 데이터베이스를 준비해서 샘플 데이터를 이식하는 방법에 대해서 잘 알고 있어야 합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Testing support was woven into the Rails fabric from the beginning. It wasn't an "oh! let's bolt on support for running tests because they're new and cool" epiphany. Just about every Rails application interacts heavily with a database and, as a result, your tests will need a database to interact with as well. To write efficient tests, you'll need to understand how to set up this database and populate it with sample data.</p><h4 id="테스트-환경-the-test-environment-원문·전체">2.1 테스트 환경<span class="original-text-h">(The Test Environment)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h4><p>디폴트로, 모든 레일스 어플리케이션은 3개의 환경을 가집니다. 즉, 개발, 테스트, 운영 환경입니다. 따라서 각각에 대한 데이터베이스 설정이 <code>config/database.yml</code> 파일에 정의되어 있습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">By default, every Rails application has three environments: development, test, and production. The database for each one of them is configured in <code>config/database.yml</code>.</p><p>테스트 전용 데이터베이스를 이용하면 별도로 테스트용 데이터를 준비해서 사용할 수 있습니다. 테스트 상에서 마음껏 테스트 데이터를 가지고 조작을 해도, 결코 개발 또는 운영 데이터베이스에 있는 데이터를 건드리지 않게 됩니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">A dedicated test database allows you to set up and interact with test data in isolation. Tests can mangle test data with confidence, that won't touch the data in the development or production databases.</p><h4 id="테스트를-위한-레일스-준비-작업-rails-sets-up-for-testing-from-the-word-go-원문·전체">2.2 테스트를 위한 레일스 준비 작업<span class="original-text-h">(Rails Sets up for Testing from the Word Go)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h4><p><code>rails new</code> <em>application_name</em> 을 실행해서 레일스 프로젝트를 생성하자마자 레일스는 <code>test</code> 폴더를 생성해 줍니다. 이 폴더의 내용을 보면 다음과 같습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Rails creates a <code>test</code> folder for you as soon as you create a Rails project using <code>rails new</code> <em>application_name</em>. If you list the contents of this folder then you shall see:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ ls -F test
controllers/    helpers/        mailers/        test_helper.rb
fixtures/       integration/    models/

</pre>
</div>
<p><code>models</code> 디렉토리에는 모델을 위한 테스트들이 위치하고, <code>controllers</code> 디렉토리에는 컨트롤러를 위한 테스트들이, 그리고 <code>integration</code> 디렉토리에는 컨트롤러들의 상호작용에 대한 테스트들이 위치하게 됩니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">The <code>models</code> directory is meant to hold tests for your models, the <code>controllers</code> directory is meant to hold tests for your controllers and the <code>integration</code> directory is meant to hold tests that involve any number of controllers interacting.</p><p>Fixtures는 테스트용 데이터를 관리하는 방법이며 <code>fixtures</code> 폴더에 위치합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Fixtures are a way of organizing test data; they reside in the <code>fixtures</code> folder.</p><p><code>test_helper.rb</code> 파일에는 테스트를 위한 디폴트 설정이 정의되어 있습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">The <code>test_helper.rb</code> file holds the default configuration for your tests.</p><h4 id="fixture에-대한-숨은-이야기-the-low-down-on-fixtures-원문·전체">2.3 Fixture에 대한 숨은 이야기<span class="original-text-h">(The Low-Down on Fixtures)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h4><p>훌륭한 테스트가 되기 위해서는 테스트 데이터를 준비하는 것을 고려해야 합니다. 레일스에서는 fixtures를 정의하고 변경할 수 있습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">For good tests, you'll need to give some thought to setting up test data. In Rails, you can handle this by defining and customizing fixtures.</p><h5 id="fixture란-무엇인가-questionmark-what-are-fixtures-questionmark-원문·전체">2.3.1 Fixture란 무엇인가?<span class="original-text-h">(What Are Fixtures?)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h5><p><em>Fixtures</em> 란 샘플 데이터에 대한 멋진 단어입니다. Fixtures를 이용하면 테스트를 실행하기 전에 테스트용 데이터베이스에 사전에 준비된 데이터를 이식할 수 있습니다. Fixtures는 YAML 포맷으로 작성되며 데이터베이스에 독립적입니다. 모델당 하나의 Fixture 파일이 존재합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text"><em>Fixtures</em> is a fancy word for sample data. Fixtures allow you to populate your testing database with predefined data before your tests run. Fixtures are database independent written in YAML. There is one file per model.</p><p><code>test/fixtures</code> 디렉토리에서 fixtures를 찾아 볼 수 있습니다. <code>rails generate mode</code> 명령을 실행하여 새로운 모델을 하나 만들게 되면 fixtures가 이 디렉토리에 자동으로 생성되어 위치하게 됩니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">You'll find fixtures under your <code>test/fixtures</code> directory. When you run <code>rails generate model</code> to create a new model fixture stubs will be automatically created and placed in this directory.</p><h5 id="yaml">2.3.2 YAML</h5><p>YAML 포맷으로 작성된 fixtures는 매우 인간 친화적인 방법으로 샘플 데이터를 기술합니다. 이와 같은 fixture의 파일 타입은 <code>users.yml</code>과 같이 <strong>.yml</strong> 파일 확장자를 가집니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">YAML-formatted fixtures are a very human-friendly way to describe your sample data. These types of fixtures have the <strong>.yml</strong> file extension (as in <code>users.yml</code>).</p><p>아래에 샘플용 YAML fixture 파일이 있습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Here's a sample YAML fixture file:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
# lo &amp; behold!  I am a YAML comment!
david:
 name: David Heinemeier Hansson
 birthday: 1979-10-15
 profession: Systems development

steve:
 name: Steve Ross Kellock
 birthday: 1974-09-27
 profession: guy with keyboard

</pre>
</div>
<p>각 fixture에 대해서 하나의 이름이 주어지고 다음에 콜론(:)으로 구분되는 키/값 쌍 목록이 들여쓰기 상태로 위치하게 됩니다. 각각의 레코드는 빈 줄로 구분됩니다. fixture 파일의 각 라인 첫번째 컬럼에 # 문자를 사용해서 코멘트를 작성할 수 있습니다. <code>yes</code>, <code>no</code>와 같은 YAML 키워드와 같은 키들은 인용구로 둘러싸서 YAML 파서가 정확하게 해석할 수 있도록 해 주어야 합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Each fixture is given a name followed by an indented list of colon-separated key/value pairs. Records are typically separated by a blank space. You can place comments in a fixture file by using the # character in the first column. Keys which resemble YAML keywords such as 'yes' and 'no' are quoted so that the YAML Parser correctly interprets them.</p><h5 id="fixture-파일에-erb-코드-삽입하기-erb-in-it-up-원문·전체">2.3.3 Fixture 파일에 ERB 코드 삽입하기<span class="original-text-h">(ERB'in It Up)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h5><p>ERB는 Fixure 테블릿 파일내에 루비코드를 삽입할 수 있게 합니다. 레일스가 fixtures를 로드할 때 YAML fixture 포맷은 ERB엔진에 의해서 사전 처리과정을 밟게 됩니다. 따라서 루비를 사용하면 샘플 데이터를 쉽게 생성할 수 있습니다. 예를 들면, 다음의 코드는 천개의 사용자를 생성해 줍니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">ERB allows you to embed Ruby code within templates. The YAML fixture format is pre-processed with ERB when Rails loads fixtures. This allows you to use Ruby to help you generate some sample data. For example, the following code generates a thousand users:</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;% 1000.times do |n| %&gt;
user_&lt;%= n %&gt;:
  username: &lt;%= "user#{n}" %&gt;
  email: &lt;%= "user#{n}@example.com" %&gt;
&lt;% end %&gt;

</pre>
</div>
<h5 id="fixtures-데이터의-동작방법-fixtures-in-action-원문·전체">2.3.4 Fixtures 데이터의 동작방법<span class="original-text-h">(Fixtures in Action)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h5><p>레일스는 디폴트로 유닛 및 기능 테스트를 위해서 <code>test/fixtures</code> 폴더의 모든 fixtures들을 자동으로 로드합니다. 로딩과정은 다음 3단계 과정을 밟게 됩니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Rails by default automatically loads all fixtures from the <code>test/fixtures</code> folder for your unit and functional test. Loading involves three steps:</p>
<ul>
<li>
<p>테이블로부터 fixture 파일에 있는 데이터와 일치하는 기존 데이터를 제거합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p>
<p class="original-text">Remove any existing data from the table corresponding to the fixture</p>
</li>
<li>
<p>테이블로 fixture 데이터를 로드합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p>
<p class="original-text">Load the fixture data into the table</p>
</li>
<li>
<p>직접 fixture 데이터로 접근할 경우를 위해서 fixture 데이터를 하나의 변수로 덤프합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p>
<p class="original-text">Dump the fixture data into a variable in case you want to access it directly</p>
</li>
</ul>
<h5 id="fixtures는-액티브레코드-객체들이다-fixtures-are-active-record-objects-원문·전체">2.3.5 Fixtures는 액티브레코드 객체들이다<span class="original-text-h">(Fixtures are Active Record objects)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h5><p>Fixtures는 액티브레코드의 인스턴스들로 생각할 수 있습니다. 위에서 3번째 언급했던 바와 같이, fixture 데이터가 자동으로 테스트 케이스의 로컬 변수로 준비되기 때문에 직접 액티브레코드 객체를 접근할 수 있게 됩니다. 예를 들면, <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">Fixtures are instances of Active Record. As mentioned in point #3 above, you can access the object directly because it is automatically setup as a local variable of the test case. For example:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# this will return the User object for the fixture named david
users(:david)

# this will return the property for david called id
users(:david).id

# one can also access methods available on the User class
email(david.girlfriend.email, david.location_tonight)

</pre>
</div>
<h3 id="모델에-대한-유닛-테스트하기-unit-testing-your-models-원문·전체">3 모델에 대한 유닛 테스트하기<span class="original-text-h">(Unit Testing your Models)</span> <sup><a href="#" class="original-link" onclick="$(this).parent().prev().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text, .original-text-h').toggle();return false;">전체}</a></sup>
</h3><p>레일스에서 유닛 테스트라 함은 모델을 테스트하기 위해서 작성한 것들을 말합니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">In Rails, unit tests are what you write to test your models.</p><p>본 가이드의 이해를 돕기 위해서, 레일스의 <em>scaffolding</em> 을 이용할 것입니다. 이것은 한번의 조작으로 새로운 리소스에 대한 모델, 마이그레이션 파일, 컨트롤러, 뷰 파일을 생성해 줄 것입니다. 또한 레일스의 우수사례에 따라 테스트를 모든 파일을 생성해 줄 것입니다. 이와 같이 생성된 테스트 코드로부터 예시를 사용할 것이고 필요하다면 예시를 추가할 것입니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">For this guide we will be using Rails <em>scaffolding</em>. It will create the model, a migration, controller and views for the new resource in a single operation. It will also create a full test suite following Rails best practices. I will be using examples from this generated code and will be supplementing it with additional examples where necessary.</p><div class="note">
<p> 레일스의 <i>scaffolding</i>에 대한 더 자세한 내용은 <a href="getting_started.html">레일스 입문하기</a>를 참고하기 바랍니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p>
<p class="original-text">For more information on Rails <i>scaffolding</i>, refer to <a href="getting_started.html">Getting Started with Rails</a></p>
</div><p><code>rails generate scaffold</code> 명령을 사용하면, 해당 리소스에 대해서 <code>test/models</code> 폴더에 테스트를 위한 파일들이 생성될 것입니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">When you use <code>rails generate scaffold</code>, for a resource among other things it creates a test stub in the <code>test/models</code> folder:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate scaffold post title:string body:text
...
create  app/models/post.rb
create  test/models/post_test.rb
create  test/fixtures/posts.yml
...

</pre>
</div>
<p><code>test/models/post_test.rb</code> 파일내의 디폴트 테스트 내용을 보면 다음과 같습니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">The default test stub in <code>test/models/post_test.rb</code> looks like this:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class PostTest &lt; ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end

</pre>
</div>
<p>이 파일에 대해서 한줄 한줄씩 살펴보면 레일스 테스트를 위한 코드와 용어에 대한 감을 잡는데 도움이 될 것입니다. <sup><a href="#" class="original-link" onclick="$(this).parent().parent().next().toggle();return false;">{원문</a><a href="#" class="original-link">·</a><a href="#" class="original-link" onclick="$('.original-text').toggle();return false;">전체}</a></sup></p><p class="original-text">A line by line examination of this file will help get you oriented to Rails testing code and terminology.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

</pre>
</div>
<p>As you know by now, <code>test_helper.rb</code> specifies the default configuration to run our tests. This is included with all the tests, so any methods added to this file are available to all your tests.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class PostTest &lt; ActiveSupport::TestCase

</pre>
</div>
<p>The <code>PostTest</code> class defines a <em>test case</em> because it inherits from <code>ActiveSupport::TestCase</code>. <code>PostTest</code> thus has all the methods available from <code>ActiveSupport::TestCase</code>. You'll see those methods a little later in this guide.</p><p>Any method defined within a class inherited from <code>MiniTest::Unit::TestCase</code> 
(which is the superclass of <code>ActiveSupport::TestCase</code>) that begins with <code>test</code> (case sensitive) is simply called a test. So, <code>test_password</code>, <code>test_valid_password</code> and <code>testValidPassword</code> all are legal test names and are run automatically when the test case is run.</p><p>Rails adds a <code>test</code> method that takes a test name and a block. It generates a normal <code>MiniTest::Unit</code> test with method names prefixed with <code>test_</code>. So,</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "the truth" do
  assert true
end

</pre>
</div>
<p>acts as if you had written</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def test_the_truth
  assert true
end

</pre>
</div>
<p>only the <code>test</code> macro allows a more readable test name. You can still use regular method definitions though.</p><div class="note"><p> The method name is generated by replacing spaces with underscores. The result does not need to be a valid Ruby identifier though, the name may contain punctuation characters etc. That's because in Ruby technically any string may be a method name. Odd ones need <code>define_method</code> and <code>send</code> calls, but formally there's no restriction.</p></div><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
assert true

</pre>
</div>
<p>This line of code is called an <em>assertion</em>. An assertion is a line of code that evaluates an object (or expression) for expected results. For example, an assertion can check:</p>
<ul>
<li>does this value = that value?</li>
<li>is this object nil?</li>
<li>does this line of code throw an exception?</li>
<li>is the user's password greater than 5 characters?</li>
</ul>
<p>Every test contains one or more assertions. Only when all the assertions are successful will the test pass.</p><h4 id="preparing-your-application-for-testing">3.1 Preparing your Application for Testing</h4><p>Before you can run your tests, you need to ensure that the test database structure is current. For this you can use the following rake commands:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake db:migrate
...
$ rake db:test:load

</pre>
</div>
<p>The <code>rake db:migrate</code> above runs any pending migrations on the <em>development</em> environment and updates <code>db/schema.rb</code>. The <code>rake db:test:load</code> recreates the test database from the current <code>db/schema.rb</code>. On subsequent attempts, it is a good idea to first run <code>db:test:prepare</code>, as it first checks for pending migrations and warns you appropriately.</p><div class="note"><p> <code>db:test:prepare</code> will fail with an error if <code>db/schema.rb</code> doesn't exist.</p></div><h5 id="rake-tasks-for-preparing-your-application-for-testing">3.1.1 Rake Tasks for Preparing your Application for Testing</h5>
<table>
<thead>
<tr>
<th>Tasks</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rake db:test:clone</code></td>
<td>Recreate the test database from the current environment's database schema</td>
</tr>
<tr>
<td><code>rake db:test:clone_structure</code></td>
<td>Recreate the test database from the development structure</td>
</tr>
<tr>
<td><code>rake db:test:load</code></td>
<td>Recreate the test database from the current <code>schema.rb</code>
</td>
</tr>
<tr>
<td><code>rake db:test:prepare</code></td>
<td>Check for pending migrations and load the test schema</td>
</tr>
<tr>
<td><code>rake db:test:purge</code></td>
<td>Empty the test database.</td>
</tr>
</tbody>
</table>
<div class="info"><p> You can see all these rake tasks and their descriptions by running <code>rake --tasks --describe</code></p></div><h4 id="running-tests">3.2 Running Tests</h4><p>Running a test is as simple as invoking the file containing the test cases through <code>rake test</code> command.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake test test/models/post_test.rb
.

Finished tests in 0.009262s, 107.9680 tests/s, 107.9680 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips

</pre>
</div>
<p>You can also run a particular test method from the test case by running the test and providing the <code>test method name</code>.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake test test/models/post_test.rb test_the_truth
.

Finished tests in 0.009064s, 110.3266 tests/s, 110.3266 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips

</pre>
</div>
<p>This will run all test methods from the test case. Note that <code>test_helper.rb</code> is in the <code>test</code> directory, hence this directory needs to be added to the load path using the <code>-I</code> switch.</p><p>The <code>.</code> (dot) above indicates a passing test. When a test fails you see an <code>F</code>; when a test throws an error you see an <code>E</code> in its place. The last line of the output is the summary.</p><p>To see how a test failure is reported, you can add a failing test to the <code>post_test.rb</code> test case.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "should not save post without title" do
  post = Post.new
  assert !post.save
end

</pre>
</div>
<p>Let us run this newly added test.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake test test/models/post_test.rb test_should_not_save_post_without_title
F

Finished tests in 0.044632s, 22.4054 tests/s, 22.4054 assertions/s.

  1) Failure:
test_should_not_save_post_without_title(PostTest) [test/models/post_test.rb:6]:
Failed assertion, no message given.

1 tests, 1 assertions, 1 failures, 0 errors, 0 skips

</pre>
</div>
<p>In the output, <code>F</code> denotes a failure. You can see the corresponding trace shown under <code>1)</code> along with the name of the failing test. The next few lines contain the stack trace followed by a message which mentions the actual value and the expected value by the assertion. The default assertion messages provide just enough information to help pinpoint the error. To make the assertion failure message more readable, every assertion provides an optional message parameter, as shown here:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "should not save post without title" do
  post = Post.new
  assert !post.save, "Saved the post without a title"
end

</pre>
</div>
<p>Running this test shows the friendlier assertion message:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
  1) Failure:
test_should_not_save_post_without_title(PostTest) [test/models/post_test.rb:6]:
Saved the post without a title

</pre>
</div>
<p>Now to get this test to pass we can add a model level validation for the <em>title</em> field.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Post &lt; ActiveRecord::Base
  validates :title, presence: true
end

</pre>
</div>
<p>Now the test should pass. Let us verify by running the test again:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake test test/models/post_test.rb test_should_not_save_post_without_title
.

Finished tests in 0.047721s, 20.9551 tests/s, 20.9551 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips

</pre>
</div>
<p>Now, if you noticed, we first wrote a test which fails for a desired functionality, then we wrote some code which adds the functionality and finally we ensured that our test passes. This approach to software development is referred to as <em>Test-Driven Development</em> (TDD).</p><div class="info"><p> Many Rails developers practice <em>Test-Driven Development</em> (TDD). This is an excellent way to build up a test suite that exercises every part of your application. TDD is beyond the scope of this guide, but one place to start is with <a href="http://andrzejonsoftware.blogspot.com/2007/05/15-tdd-steps-to-create-rails.html">15 TDD steps to create a Rails application</a>.</p></div><p>To see how an error gets reported, here's a test containing an error:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end

</pre>
</div>
<p>Now you can see even more output in the console from running the tests:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake test test/models/post_test.rb test_should_report_error
E

Finished tests in 0.030974s, 32.2851 tests/s, 0.0000 assertions/s.

  1) Error:
test_should_report_error(PostTest):
NameError: undefined local variable or method `some_undefined_variable' for #&lt;PostTest:0x007fe32e24afe0&gt;
    test/models/post_test.rb:10:in `block in &lt;class:PostTest&gt;'

1 tests, 0 assertions, 0 failures, 1 errors, 0 skips

</pre>
</div>
<p>Notice the 'E' in the output. It denotes a test with error.</p><div class="note"><p> The execution of each test method stops as soon as any error or an assertion failure is encountered, and the test suite continues with the next method. All test methods are executed in alphabetical order.</p></div><h4 id="what-to-include-in-your-unit-tests">3.3 What to Include in Your Unit Tests</h4><p>Ideally, you would like to include a test for everything which could possibly break. It's a good practice to have at least one test for each of your validations and at least one test for every method in your model.</p><h4 id="available-assertions">3.4 Available Assertions</h4><p>By now you've caught a glimpse of some of the assertions that are available. Assertions are the worker bees of testing. They are the ones that actually perform the checks to ensure that things are going as planned.</p><p>There are a bunch of different types of assertions you can use.
Here's an extract of the assertions you can use with <code>minitest</code>, the default testing library used by Rails. The <code>[msg]</code> parameter is an optional string message you can specify to make your test failure messages clearer. It's not required.</p>
<table>
<thead>
<tr>
<th>Assertion</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>assert( test, [msg] )</code></td>
<td>Ensures that <code>test</code> is true.</td>
</tr>
<tr>
<td><code>refute( test, [msg] )</code></td>
<td>Ensures that <code>test</code> is false.</td>
</tr>
<tr>
<td><code>assert_equal( expected, actual, [msg] )</code></td>
<td>Ensures that <code>expected == actual</code> is true.</td>
</tr>
<tr>
<td><code>refute_equal( expected, actual, [msg] )</code></td>
<td>Ensures that <code>expected != actual</code> is true.</td>
</tr>
<tr>
<td><code>assert_same( expected, actual, [msg] )</code></td>
<td>Ensures that <code>expected.equal?(actual)</code> is true.</td>
</tr>
<tr>
<td><code>refute_same( expected, actual, [msg] )</code></td>
<td>Ensures that <code>expected.equal?(actual)</code> is false.</td>
</tr>
<tr>
<td><code>assert_nil( obj, [msg] )</code></td>
<td>Ensures that <code>obj.nil?</code> is true.</td>
</tr>
<tr>
<td><code>refute_nil( obj, [msg] )</code></td>
<td>Ensures that <code>obj.nil?</code> is false.</td>
</tr>
<tr>
<td><code>assert_match( regexp, string, [msg] )</code></td>
<td>Ensures that a string matches the regular expression.</td>
</tr>
<tr>
<td><code>refute_match( regexp, string, [msg] )</code></td>
<td>Ensures that a string doesn't match the regular expression.</td>
</tr>
<tr>
<td><code>assert_in_delta( expecting, actual, [delta], [msg] )</code></td>
<td>Ensures that the numbers <code>expected</code> and <code>actual</code> are within <code>delta</code> of each other.</td>
</tr>
<tr>
<td><code>refute_in_delta( expecting, actual, [delta], [msg] )</code></td>
<td>Ensures that the numbers <code>expected</code> and <code>actual</code> are not within <code>delta</code> of each other.</td>
</tr>
<tr>
<td><code>assert_throws( symbol, [msg] ) { block }</code></td>
<td>Ensures that the given block throws the symbol.</td>
</tr>
<tr>
<td><code>assert_raises( exception1, exception2, ... ) { block }</code></td>
<td>Ensures that the given block raises one of the given exceptions.</td>
</tr>
<tr>
<td><code>assert_nothing_raised( exception1, exception2, ... ) { block }</code></td>
<td>Ensures that the given block doesn't raise one of the given exceptions.</td>
</tr>
<tr>
<td><code>assert_instance_of( class, obj, [msg] )</code></td>
<td>Ensures that <code>obj</code> is an instance of <code>class</code>.</td>
</tr>
<tr>
<td><code>refute_instance_of( class, obj, [msg] )</code></td>
<td>Ensures that <code>obj</code> is not an instance of <code>class</code>.</td>
</tr>
<tr>
<td><code>assert_kind_of( class, obj, [msg] )</code></td>
<td>Ensures that <code>obj</code> is or descends from <code>class</code>.</td>
</tr>
<tr>
<td><code>refute_kind_of( class, obj, [msg] )</code></td>
<td>Ensures that <code>obj</code> is not an instance of <code>class</code> and is not descending from it.</td>
</tr>
<tr>
<td><code>assert_respond_to( obj, symbol, [msg] )</code></td>
<td>Ensures that <code>obj</code> responds to <code>symbol</code>.</td>
</tr>
<tr>
<td><code>refute_respond_to( obj, symbol, [msg] )</code></td>
<td>Ensures that <code>obj</code> does not respond to <code>symbol</code>.</td>
</tr>
<tr>
<td><code>assert_operator( obj1, operator, [obj2], [msg] )</code></td>
<td>Ensures that <code>obj1.operator(obj2)</code> is true.</td>
</tr>
<tr>
<td><code>refute_operator( obj1, operator, [obj2], [msg] )</code></td>
<td>Ensures that <code>obj1.operator(obj2)</code> is false.</td>
</tr>
<tr>
<td><code>assert_send( array, [msg] )</code></td>
<td>Ensures that executing the method listed in <code>array[1]</code> on the object in <code>array[0]</code> with the parameters of <code>array[2 and up]</code> is true. This one is weird eh?</td>
</tr>
<tr>
<td><code>flunk( [msg] )</code></td>
<td>Ensures failure. This is useful to explicitly mark a test that isn't finished yet.</td>
</tr>
</tbody>
</table>
<p>Because of the modular nature of the testing framework, it is possible to create your own assertions. In fact, that's exactly what Rails does. It includes some specialized assertions to make your life easier.</p><div class="note"><p> Creating your own assertions is an advanced topic that we won't cover in this tutorial.</p></div><h4 id="rails-specific-assertions">3.5 Rails Specific Assertions</h4><p>Rails adds some custom assertions of its own to the <code>test/unit</code> framework:</p>
<table>
<thead>
<tr>
<th>Assertion</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>assert_difference(expressions, difference = 1, message = nil) {...}</code></td>
<td>Test numeric difference between the return value of an expression as a result of what is evaluated in the yielded block.</td>
</tr>
<tr>
<td><code>assert_no_difference(expressions, message = nil, &amp;amp;block)</code></td>
<td>Asserts that the numeric result of evaluating an expression is not changed before and after invoking the passed in block.</td>
</tr>
<tr>
<td><code>assert_recognizes(expected_options, path, extras={}, message=nil)</code></td>
<td>Asserts that the routing of the given path was handled correctly and that the parsed options (given in the expected_options hash) match path. Basically, it asserts that Rails recognizes the route given by expected_options.</td>
</tr>
<tr>
<td><code>assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)</code></td>
<td>Asserts that the provided options can be used to generate the provided path. This is the inverse of assert_recognizes. The extras parameter is used to tell the request the names and values of additional request parameters that would be in a query string. The message parameter allows you to specify a custom error message for assertion failures.</td>
</tr>
<tr>
<td><code>assert_response(type, message = nil)</code></td>
<td>Asserts that the response comes with a specific status code. You can specify <code>:success</code> to indicate 200-299,  <code>:redirect</code> to indicate 300-399, <code>:missing</code> to indicate 404, or <code>:error</code> to match the 500-599 range</td>
</tr>
<tr>
<td><code>assert_redirected_to(options = {}, message=nil)</code></td>
<td>Assert that the redirection options passed in match those of the redirect called in the latest action. This match can be partial, such that <code>assert_redirected_to(controller: "weblog")</code> will also match the redirection of <code>redirect_to(controller: "weblog", action: "show")</code> and so on.</td>
</tr>
<tr>
<td><code>assert_template(expected = nil, message=nil)</code></td>
<td>Asserts that the request was rendered with the appropriate template file.</td>
</tr>
</tbody>
</table>
<p>You'll see the usage of some of these assertions in the next chapter.</p><h3 id="functional-tests-for-your-controllers">4 Functional Tests for Your Controllers</h3><p>In Rails, testing the various actions of a single controller is called writing functional tests for that controller. Controllers handle the incoming web requests to your application and eventually respond with a rendered view.</p><h4 id="what-to-include-in-your-functional-tests">4.1 What to Include in your Functional Tests</h4><p>You should test for things such as:</p>
<ul>
<li>was the web request successful?</li>
<li>was the user redirected to the right page?</li>
<li>was the user successfully authenticated?</li>
<li>was the correct object stored in the response template?</li>
<li>was the appropriate message displayed to the user in the view?</li>
</ul>
<p>Now that we have used Rails scaffold generator for our <code>Post</code> resource, it has already created the controller code and tests. You can take look at the file <code>posts_controller_test.rb</code> in the <code>test/controllers</code> directory.</p><p>Let me take you through one such test, <code>test_should_get_index</code> from the file <code>posts_controller_test.rb</code>.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "should get index" do
  get :index
  assert_response :success
  assert_not_nil assigns(:posts)
end

</pre>
</div>
<p>In the <code>test_should_get_index</code> test, Rails simulates a request on the action called <code>index</code>, making sure the request was successful and also ensuring that it assigns a valid <code>posts</code> instance variable.</p><p>The <code>get</code> method kicks off the web request and populates the results into the response. It accepts 4 arguments:</p>
<ul>
<li>The action of the controller you are requesting. This can be in the form of a string or a symbol.</li>
<li>An optional hash of request parameters to pass into the action (eg. query string parameters or post variables).</li>
<li>An optional hash of session variables to pass along with the request.</li>
<li>An optional hash of flash values.</li>
</ul>
<p>Example: Calling the <code>:show</code> action, passing an <code>id</code> of 12 as the <code>params</code> and setting a <code>user_id</code> of 5 in the session:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
get(:show, {'id' =&gt; "12"}, {'user_id' =&gt; 5})

</pre>
</div>
<p>Another example: Calling the <code>:view</code> action, passing an <code>id</code> of 12 as the <code>params</code>, this time with no session, but with a flash message.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
get(:view, {'id' =&gt; '12'}, nil, {'message' =&gt; 'booya!'})

</pre>
</div>
<div class="note"><p> If you try running <code>test_should_create_post</code> test from <code>posts_controller_test.rb</code> it will fail on account of the newly added model level validation and rightly so.</p></div><p>Let us modify <code>test_should_create_post</code> test in <code>posts_controller_test.rb</code> so that all our test pass:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "should create post" do
  assert_difference('Post.count') do
    post :create, post: {title: 'Some title'}
  end

  assert_redirected_to post_path(assigns(:post))
end

</pre>
</div>
<p>Now you can try running all the tests and they should pass.</p><h4 id="available-request-types-for-functional-tests">4.2 Available Request Types for Functional Tests</h4><p>If you're familiar with the HTTP protocol, you'll know that <code>get</code> is a type of request. There are 6 request types supported in Rails functional tests:</p>
<ul>
<li><code>get</code></li>
<li><code>post</code></li>
<li><code>patch</code></li>
<li><code>put</code></li>
<li><code>head</code></li>
<li><code>delete</code></li>
</ul>
<p>All of request types are methods that you can use, however, you'll probably end up using the first two more often than the others.</p><div class="note"><p> Functional tests do not verify whether the specified request type should be accepted by the action. Request types in this context exist to make your tests more descriptive.</p></div><h4 id="the-four-hashes-of-the-apocalypse">4.3 The Four Hashes of the Apocalypse</h4><p>After a request has been made using one of the 6 methods (<code>get</code>, <code>post</code>, etc.) and processed, you will have 4 Hash objects ready for use:</p>
<ul>
<li>
<code>assigns</code> - Any objects that are stored as instance variables in actions for use in views.</li>
<li>
<code>cookies</code> - Any cookies that are set.</li>
<li>
<code>flash</code> - Any objects living in the flash.</li>
<li>
<code>session</code> - Any object living in session variables.</li>
</ul>
<p>As is the case with normal Hash objects, you can access the values by referencing the keys by string. You can also reference them by symbol name, except for <code>assigns</code>. For example:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
flash["gordon"]               flash[:gordon]
session["shmession"]          session[:shmession]
cookies["are_good_for_u"]     cookies[:are_good_for_u]

# Because you can't use assigns[:something] for historical reasons:
assigns["something"]          assigns(:something)

</pre>
</div>
<h4 id="instance-variables-available">4.4 Instance Variables Available</h4><p>You also have access to three instance variables in your functional tests:</p>
<ul>
<li>
<code>@controller</code> - The controller processing the request</li>
<li>
<code>@request</code> - The request</li>
<li>
<code>@response</code> - The response</li>
</ul>
<h4 id="setting-headers-and-cgi-variables">4.5 Setting Headers and CGI variables</h4><p>Headers and cgi variables can be set directly on the <code>@request</code>
instance variable:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# setting a HTTP Header
@request.headers["Accepts"] = "text/plain, text/html"
get :index # simulate the request with custom header

# setting a CGI variable
@request.headers["HTTP_REFERER"] = "http://example.com/home"
post :create # simulate the request with custom env variable

</pre>
</div>
<h4 id="testing-templates-and-layouts">4.6 Testing Templates and Layouts</h4><p>If you want to make sure that the response rendered the correct template and layout, you can use the <code>assert_template</code>
method:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "index should render correct template and layout" do
  get :index
  assert_template :index
  assert_template layout: "layouts/application"
end

</pre>
</div>
<p>Note that you cannot test for template and layout at the same time, with one call to <code>assert_template</code> method.
Also, for the <code>layout</code> test, you can give a regular expression instead of a string, but using the string, makes
things clearer. On the other hand, you have to include the "layouts" directory name even if you save your layout
file in this standard layout directory. Hence,</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
assert_template layout: "application"

</pre>
</div>
<p>will not work.</p><p>If your view renders any partial, when asserting for the layout, you have to assert for the partial at the same time.
Otherwise, assertion will fail.</p><p>Hence:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "new should render correct layout" do
  get :new
  assert_template layout: "layouts/application", partial: "_form"
end

</pre>
</div>
<p>is the correct way to assert for the layout when the view renders a partial with name <code>_form</code>. Omitting the <code>:partial</code> key in your <code>assert_template</code> call will complain.</p><h4 id="a-fuller-functional-test-example">4.7 A Fuller Functional Test Example</h4><p>Here's another example that uses <code>flash</code>, <code>assert_redirected_to</code>, and <code>assert_difference</code>:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "should create post" do
  assert_difference('Post.count') do
    post :create, post: {title: 'Hi', body: 'This is my first post.'}
  end
  assert_redirected_to post_path(assigns(:post))
  assert_equal 'Post was successfully created.', flash[:notice]
end

</pre>
</div>
<h4 id="testing-views">4.8 Testing Views</h4><p>Testing the response to your request by asserting the presence of key HTML elements and their content is a useful way to test the views of your application. The <code>assert_select</code> assertion allows you to do this by using a simple yet powerful syntax.</p><div class="note"><p> You may find references to <code>assert_tag</code> in other documentation, but this is now deprecated in favor of <code>assert_select</code>.</p></div><p>There are two forms of <code>assert_select</code>:</p><p><code>assert_select(selector, [equality], [message])</code> ensures that the equality condition is met on the selected elements through the selector. The selector may be a CSS selector expression (String), an expression with substitution values, or an <code>HTML::Selector</code> object.</p><p><code>assert_select(element, selector, [equality], [message])</code> ensures that the equality condition is met on all the selected elements through the selector starting from the <em>element</em> (instance of <code>HTML::Node</code>) and its descendants.</p><p>For example, you could verify the contents on the title element in your response with:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
assert_select 'title', "Welcome to Rails Testing Guide"

</pre>
</div>
<p>You can also use nested <code>assert_select</code> blocks. In this case the inner <code>assert_select</code> runs the assertion on the complete collection of elements selected by the outer <code>assert_select</code> block:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
assert_select 'ul.navigation' do
  assert_select 'li.menu_item'
end

</pre>
</div>
<p>Alternatively the collection of elements selected by the outer <code>assert_select</code> may be iterated through so that <code>assert_select</code> may be called separately for each element. Suppose for example that the response contains two ordered lists, each with four list elements then the following tests will both pass.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
assert_select "ol" do |elements|
  elements.each do |element|
    assert_select element, "li", 4
  end
end

assert_select "ol" do
  assert_select "li", 8
end

</pre>
</div>
<p>The <code>assert_select</code> assertion is quite powerful. For more advanced usage, refer to its <a href="http://api.rubyonrails.org/classes/ActionDispatch/Assertions/SelectorAssertions.html">documentation</a>.</p><h5 id="additional-view-based-assertions">4.8.1 Additional View-Based Assertions</h5><p>There are more assertions that are primarily used in testing views:</p>
<table>
<thead>
<tr>
<th>Assertion</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>assert_select_email</code></td>
<td>Allows you to make assertions on the body of an e-mail.</td>
</tr>
<tr>
<td><code>assert_select_encoded</code></td>
<td>Allows you to make assertions on encoded HTML. It does this by un-encoding the contents of each element and then calling the block with all the un-encoded elements.</td>
</tr>
<tr>
<td>
<code>css_select(selector)</code>  or <code>css_select(element, selector)</code>
</td>
<td>Returns an array of all the elements selected by the <em>selector</em>. In the second variant it first matches the base <em>element</em> and tries to match the <em>selector</em> expression on any of its children. If there are no matches both variants return an empty array.</td>
</tr>
</tbody>
</table>
<p>Here's an example of using <code>assert_select_email</code>:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
assert_select_email do
  assert_select 'small', 'Please click the "Unsubscribe" link if you want to opt-out.'
end

</pre>
</div>
<h3 id="integration-testing">5 Integration Testing</h3><p>Integration tests are used to test the interaction among any number of controllers. They are generally used to test important work flows within your application.</p><p>Unlike Unit and Functional tests, integration tests have to be explicitly created under the 'test/integration' folder within your application. Rails provides a generator to create an integration test skeleton for you.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate integration_test user_flows
      exists  test/integration/
      create  test/integration/user_flows_test.rb

</pre>
</div>
<p>Here's what a freshly-generated integration test looks like:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  # test "the truth" do
  #   assert true
  # end
end

</pre>
</div>
<p>Integration tests inherit from <code>ActionDispatch::IntegrationTest</code>. This makes available some additional helpers to use in your integration tests. Also you need to explicitly include the fixtures to be made available to the test.</p><h4 id="helpers-available-for-integration-tests">5.1 Helpers Available for Integration Tests</h4><p>In addition to the standard testing helpers, there are some additional helpers available to integration tests:</p>
<table>
<thead>
<tr>
<th>Helper</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>https?</code></td>
<td>Returns <code>true</code> if the session is mimicking a secure HTTPS request.</td>
</tr>
<tr>
<td><code>https!</code></td>
<td>Allows you to mimic a secure HTTPS request.</td>
</tr>
<tr>
<td><code>host!</code></td>
<td>Allows you to set the host name to use in the next request.</td>
</tr>
<tr>
<td><code>redirect?</code></td>
<td>Returns <code>true</code> if the last request was a redirect.</td>
</tr>
<tr>
<td><code>follow_redirect!</code></td>
<td>Follows a single redirect response.</td>
</tr>
<tr>
<td><code>request_via_redirect(http_method, path, [parameters], [headers])</code></td>
<td>Allows you to make an HTTP request and follow any subsequent redirects.</td>
</tr>
<tr>
<td><code>post_via_redirect(path, [parameters], [headers])</code></td>
<td>Allows you to make an HTTP POST request and follow any subsequent redirects.</td>
</tr>
<tr>
<td><code>get_via_redirect(path, [parameters], [headers])</code></td>
<td>Allows you to make an HTTP GET request and follow any subsequent redirects.</td>
</tr>
<tr>
<td><code>patch_via_redirect(path, [parameters], [headers])</code></td>
<td>Allows you to make an HTTP PATCH request and follow any subsequent redirects.</td>
</tr>
<tr>
<td><code>put_via_redirect(path, [parameters], [headers])</code></td>
<td>Allows you to make an HTTP PUT request and follow any subsequent redirects.</td>
</tr>
<tr>
<td><code>delete_via_redirect(path, [parameters], [headers])</code></td>
<td>Allows you to make an HTTP DELETE request and follow any subsequent redirects.</td>
</tr>
<tr>
<td><code>open_session</code></td>
<td>Opens a new session instance.</td>
</tr>
</tbody>
</table>
<h4 id="integration-testing-examples">5.2 Integration Testing Examples</h4><p>A simple integration test that exercises multiple controllers:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  fixtures :users

  test "login and browse site" do
    # login via https
    https!
    get "/login"
    assert_response :success

    post_via_redirect "/login", username: users(:david).username, password: users(:david).password
    assert_equal '/welcome', path
    assert_equal 'Welcome david!', flash[:notice]

    https!(false)
    get "/posts/all"
    assert_response :success
    assert assigns(:products)
  end
end

</pre>
</div>
<p>As you can see the integration test involves multiple controllers and exercises the entire stack from database to dispatcher. In addition you can have multiple session instances open simultaneously in a test and extend those instances with assertion methods to create a very powerful testing DSL (domain-specific language) just for your application.</p><p>Here's an example of multiple sessions and custom DSL in an integration test</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  fixtures :users

  test "login and browse site" do

    # User david logs in
    david = login(:david)
    # User guest logs in
    guest = login(:guest)

    # Both are now available in different sessions
    assert_equal 'Welcome david!', david.flash[:notice]
    assert_equal 'Welcome guest!', guest.flash[:notice]

    # User david can browse site
    david.browses_site
    # User guest can browse site as well
    guest.browses_site

    # Continue with other assertions
  end

  private

  module CustomDsl
    def browses_site
      get "/products/all"
      assert_response :success
      assert assigns(:products)
    end
  end

  def login(user)
    open_session do |sess|
      sess.extend(CustomDsl)
      u = users(user)
      sess.https!
      sess.post "/login", username: u.username, password: u.password
      assert_equal '/welcome', path
      sess.https!(false)
    end
  end
end

</pre>
</div>
<h3 id="rake-tasks-for-running-your-tests">6 Rake Tasks for Running your Tests</h3><p>You don't need to set up and run your tests by hand on a test-by-test basis. Rails comes with a number of commands to help in testing. The table below lists all commands that come along in the default Rakefile when you initiate a Rails project.</p>
<table>
<thead>
<tr>
<th>Tasks</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rake test</code></td>
<td>Runs all unit, functional and integration tests. You can also simply run <code>rake test</code> as Rails will run all the tests by default</td>
</tr>
<tr>
<td><code>rake test:controllers</code></td>
<td>Runs all the controller tests from <code>test/controllers</code>
</td>
</tr>
<tr>
<td><code>rake test:functionals</code></td>
<td>Runs all the functional tests from <code>test/controllers</code>, <code>test/mailers</code>, and <code>test/functional</code>
</td>
</tr>
<tr>
<td><code>rake test:helpers</code></td>
<td>Runs all the helper tests from <code>test/helpers</code>
</td>
</tr>
<tr>
<td><code>rake test:integration</code></td>
<td>Runs all the integration tests from <code>test/integration</code>
</td>
</tr>
<tr>
<td><code>rake test:mailers</code></td>
<td>Runs all the mailer tests from <code>test/mailers</code>
</td>
</tr>
<tr>
<td><code>rake test:models</code></td>
<td>Runs all the model tests from <code>test/models</code>
</td>
</tr>
<tr>
<td><code>rake test:units</code></td>
<td>Runs all the unit tests from <code>test/models</code>, <code>test/helpers</code>, and <code>test/unit</code>
</td>
</tr>
</tbody>
</table>
<p>There're also some test commands which you can initiate by running rake tasks:</p>
<table>
<thead>
<tr>
<th>Tasks</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rake test</code></td>
<td>Runs all unit, functional and integration tests. You can also simply run <code>rake</code> as the <em>test</em> target is the default.</td>
</tr>
<tr>
<td><code>rake test:recent</code></td>
<td>Tests recent changes</td>
</tr>
<tr>
<td><code>rake test:uncommitted</code></td>
<td>Runs all the tests which are uncommitted. Supports Subversion and Git</td>
</tr>
</tbody>
</table>
<h3 id="brief-note-about-minitest">7 Brief Note About <code>MiniTest</code>
</h3><p>Ruby ships with a boat load of libraries. Ruby 1.8 provides <code>Test::Unit</code>, a framework for unit testing in Ruby. All the basic assertions discussed above are actually defined in <code>Test::Unit::Assertions</code>. The class <code>ActiveSupport::TestCase</code> which we have been using in our unit and functional tests extends <code>Test::Unit::TestCase</code>, allowing
us to use all of the basic assertions in our tests.</p><p>Ruby 1.9 introduced <code>MiniTest</code>, an updated version of <code>Test::Unit</code> which provides a backwards compatible API for <code>Test::Unit</code>. You could also use <code>MiniTest</code> in Ruby 1.8 by installing the <code>minitest</code> gem.</p><div class="note"><p> For more information on <code>Test::Unit</code>, refer to <a href="http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/">test/unit Documentation</a>
For more information on <code>MiniTest</code>, refer to <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/minitest/unit/rdoc/">Minitest</a></p></div><h3 id="setup-and-teardown">8 Setup and Teardown</h3><p>If you would like to run a block of code before the start of each test and another block of code after the end of each test you have two special callbacks for your rescue. Let's take note of this by looking at an example for our functional test in <code>Posts</code> controller:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class PostsControllerTest &lt; ActionController::TestCase

  # called before every single test
  def setup
    @post = posts(:one)
  end

  # called after every single test
  def teardown
    # as we are re-initializing @post before every test
    # setting it to nil here is not essential but I hope
    # you understand how you can use the teardown method
    @post = nil
  end

  test "should show post" do
    get :show, id: @post.id
    assert_response :success
  end

  test "should destroy post" do
    assert_difference('Post.count', -1) do
      delete :destroy, id: @post.id
    end

    assert_redirected_to posts_path
  end

end

</pre>
</div>
<p>Above, the <code>setup</code> method is called before each test and so <code>@post</code> is available for each of the tests. Rails implements <code>setup</code> and <code>teardown</code> as <code>ActiveSupport::Callbacks</code>. Which essentially means you need not only use <code>setup</code> and <code>teardown</code> as methods in your tests. You could specify them by using:</p>
<ul>
<li>a block</li>
<li>a method (like in the earlier example)</li>
<li>a method name as a symbol</li>
<li>a lambda</li>
</ul>
<p>Let's see the earlier example by specifying <code>setup</code> callback by specifying a method name as a symbol:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class PostsControllerTest &lt; ActionController::TestCase

  # called before every single test
  setup :initialize_post

  # called after every single test
  def teardown
    @post = nil
  end

  test "should show post" do
    get :show, id: @post.id
    assert_response :success
  end

  test "should update post" do
    patch :update, id: @post.id, post: {}
    assert_redirected_to post_path(assigns(:post))
  end

  test "should destroy post" do
    assert_difference('Post.count', -1) do
      delete :destroy, id: @post.id
    end

    assert_redirected_to posts_path
  end

  private

  def initialize_post
    @post = posts(:one)
  end

end

</pre>
</div>
<h3 id="testing-routes">9 Testing Routes</h3><p>Like everything else in your Rails application, it is recommended that you test your routes. An example test for a route in the default <code>show</code> action of <code>Posts</code> controller above should look like:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
test "should route to post" do
  assert_routing '/posts/1', {controller: "posts", action: "show", id: "1"}
end

</pre>
</div>
<h3 id="testing-your-mailers">10 Testing Your Mailers</h3><p>Testing mailer classes requires some specific tools to do a thorough job.</p><h4 id="keeping-the-postman-in-check">10.1 Keeping the Postman in Check</h4><p>Your mailer classes — like every other part of your Rails application — should be tested to ensure that it is working as expected.</p><p>The goals of testing your mailer classes are to ensure that:</p>
<ul>
<li>emails are being processed (created and sent)</li>
<li>the email content is correct (subject, sender, body, etc)</li>
<li>the right emails are being sent at the right times</li>
</ul>
<h5 id="from-all-sides">10.1.1 From All Sides</h5><p>There are two aspects of testing your mailer, the unit tests and the functional tests. In the unit tests, you run the mailer in isolation with tightly controlled inputs and compare the output to a known value (a fixture.) In the functional tests you don't so much test the minute details produced by the mailer; instead, we test that our controllers and models are using the mailer in the right way. You test to prove that the right email was sent at the right time.</p><h4 id="unit-testing">10.2 Unit Testing</h4><p>In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced.</p><h5 id="revenge-of-the-fixtures">10.2.1 Revenge of the Fixtures</h5><p>For the purposes of unit testing a mailer, fixtures are used to provide an example of how the output <em>should</em> look. Because these are example emails, and not Active Record data like the other fixtures, they are kept in their own subdirectory apart from the other fixtures. The name of the directory within <code>test/fixtures</code> directly corresponds to the name of the mailer. So, for a mailer named <code>UserMailer</code>, the fixtures should reside in <code>test/fixtures/user_mailer</code> directory.</p><p>When you generated your mailer, the generator creates stub fixtures for each of the mailers actions. If you didn't use the generator you'll have to make those files yourself.</p><h5 id="the-basic-test-case">10.2.2 The Basic Test Case</h5><p>Here's a unit test to test a mailer named <code>UserMailer</code> whose action <code>invite</code> is used to send an invitation to a friend. It is an adapted version of the base test created by the generator for an <code>invite</code> action.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class UserMailerTest &lt; ActionMailer::TestCase
  tests UserMailer
  test "invite" do
    # Send the email, then test that it got queued
    email = UserMailer.create_invite('me@example.com',
                                     'friend@example.com', Time.now).deliver
    assert !ActionMailer::Base.deliveries.empty?

    # Test the body of the sent email contains what we expect it to
    assert_equal ['me@example.com'], email.from
    assert_equal ['friend@example.com'], email.to
    assert_equal 'You have been invited by me@example.com', email.subject
    assert_equal read_fixture('invite').join, email.body.to_s
  end
end

</pre>
</div>
<p>In the test we send the email and store the returned object in the <code>email</code>
variable. We then ensure that it was sent (the first assert), then, in the
second batch of assertions, we ensure that the email does indeed contain what we
expect. The helper <code>read_fixture</code> is used to read in the content from this file.</p><p>Here's the content of the <code>invite</code> fixture:</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
Hi friend@example.com,

You have been invited.

Cheers!

</pre>
</div>
<p>This is the right time to understand a little more about writing tests for your
mailers. The line <code>ActionMailer::Base.delivery_method = :test</code> in
<code>config/environments/test.rb</code> sets the delivery method to test mode so that
email will not actually be delivered (useful to avoid spamming your users while
testing) but instead it will be appended to an array
(<code>ActionMailer::Base.deliveries</code>).</p><div class="note"><p> The <code>ActionMailer::Base.deliveries</code> array is only reset automatically in
<code>ActionMailer::TestCase</code> tests. If you want to have a clean slate outside Action
Mailer tests, you can reset it manually with:
<code>ActionMailer::Base.deliveries.clear</code></p></div><h4 id="functional-testing">10.3 Functional Testing</h4><p>Functional testing for mailers involves more than just checking that the email body, recipients and so forth are correct. In functional mail tests you call the mail deliver methods and check that the appropriate emails have been appended to the delivery list. It is fairly safe to assume that the deliver methods themselves do their job. You are probably more interested in whether your own business logic is sending emails when you expect them to go out. For example, you can check that the invite friend operation is sending an email appropriately:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class UserControllerTest &lt; ActionController::TestCase
  test "invite friend" do
    assert_difference 'ActionMailer::Base.deliveries.size', +1 do
      post :invite_friend, email: 'friend@example.com'
    end
    invite_email = ActionMailer::Base.deliveries.last

    assert_equal "You have been invited by me@example.com", invite_email.subject
    assert_equal 'friend@example.com', invite_email.to[0]
    assert_match(/Hi friend@example.com/, invite_email.body)
  end
end

</pre>
</div>
<h3 id="other-testing-approaches">11 Other Testing Approaches</h3><p>The built-in <code>test/unit</code> based testing is not the only way to test Rails applications. Rails developers have come up with a wide variety of other approaches and aids for testing, including:</p>
<ul>
<li>
<a href="http://avdi.org/projects/nulldb/">NullDB</a>, a way to speed up testing by avoiding database use.</li>
<li>
<a href="https://github.com/thoughtbot/factory_girl/tree/master">Factory Girl</a>, a replacement for fixtures.</li>
<li>
<a href="https://github.com/notahat/machinist/tree/master">Machinist</a>, another replacement for fixtures.</li>
<li>
<a href="https://github.com/metaskills/minitest-spec-rails">MiniTest::Spec Rails</a>, use the MiniTest::Spec DSL within your rails tests.</li>
<li>
<a href="http://www.thoughtbot.com/projects/shoulda">Shoulda</a>, an extension to <code>test/unit</code> with additional helpers, macros, and assertions.</li>
<li>
<a href="http://relishapp.com/rspec">RSpec</a>, a behavior-driven development framework</li>
</ul>


        <h3>피드백</h3>
        <p>
          이 가이드의 질을 향상시키기 위한 도움을 기다리고 있습니다.
        </p>
        <p>
          수정이 필요한 오타나 에러를 발견하면 <a href="https://github.com/lifo/docrails">docrails</a>을 클론한 후 직접 변경내용을 push하시기 바랍니다. 레일스의 해당 브랜치는 누구나가 write 권한이 있습니다. 커밋한 내용에 대해서는 검토작업이 이루어질 것이지만 변경내용을 서밋한 이후에 진행됩니다. <a href="https://github.com/lifo/docrails">docrails</a>은 정기적으로 master 브랜치와 클로스 머지됩니다. 
        </p>
        <p>
          미완성된 내용이나 업데이트되지 않은 내용이 있을 수 있습니다. 누락된 문서를 추가해 주시기 바랍니다. 문서작성시 참고해야할 스타일과 규칙은 <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>를 확인하시기 바랍니다. 
        </p>
        <p>
          어떤 이유에서든지, 수정이 필요한 부분을 직접 변경할 수 없는 경우에는 <a href="https://github.com/rails/rails/issues">open an issue</a>로 접속하여 문제점을 제출해 주시기 바랍니다. 
        </p>
        <p>
          마지막으로, 루비온레일스 문서화에 관련된 논의가 필요한 사항은 <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs mailing list</a>에서 해 주시기 바랍니다. 
        </p>
        <h3>문서생성일</h3>
        <p>최종 생성일 : 2015-01-26 09:09:21 +0900 </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>이 작업은 <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License 특허권을 가지고 있습니다.</p>
<p>"Rails", "Ruby on Rails", 그리고 레일스 로고는 David Heinemeier Hansson의 등록상표이며, 저작권 보호를 받고 있습니다.</p>


    </div>
  </div>

  <script type="text/javascript" src="javascripts/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/responsive-tables.js"></script>
  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all()
    $(guidesIndex.bind);
  </script>
</body>
</html>
